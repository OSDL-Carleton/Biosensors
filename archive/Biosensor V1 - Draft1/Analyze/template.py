# -*- coding: utf-8 -*-
"""main-oegfet (V2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AUFYXsm393wG60-wEzykY3aFBDRrH8zZ
"""

!pip install pandas
!pip install matplotlib
!pip install scipy

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import matplotlib.pyplot as plt


file_path = '/content/drive/My Drive/T3_VSD_ISID_v3_v1.csv'
df = pd.read_csv(file_path, skiprows=4)


Vsd = df['X-Axis (V) - Vd']

fig, ax = plt.subplots(figsize=(12, 8))


Isd_columns = df.columns[2:10]
Id_columns = df.columns[11:19]


for col in Isd_columns:
    Vsg_label = col.split(' ')[0]
    ax.plot(Vsd, df[col], label=f'Is, Vsg = {Vsg_label}V', linestyle='-')


for col in Id_columns:
    Vsg_label = col.split(' ')[0]
    ax.plot(Vsd, df[col], label=f'Id, Vsg = {Vsg_label}V', linestyle='--')

ax.set_xlabel('Vsd (V)')
ax.set_ylabel('Current (A)')
ax.set_title('Is and Id vs Vsd for different Vsg values')
ax.legend(loc='upper left', bbox_to_anchor=(1, 1))

plt.tight_layout()
plt.show()

"""#Preperation of data

"""

import pandas as pd
import os


folder_path = '/content/drive/My Drive/Masters/OEGFET-RawData'


chip_files = {
    'MWT1': ['T3_VSD_ISID_v1.csv', 'T5_VSD_ISID_v1.csv'],
    'MWT2': ['T4_VSD_ISID_v1.csv', 'T5_VSD_ISID_v1.csv'],
    'MWT3': ['T4_VSD_ISID_v1.csv', 'T5_VSD_ISID_v1.csv'],
    'MWT4': ['T4_VSD_ISID_v1.csv', 'T5_VSD_ISID_v1.csv'],
    'MWT5': ['T4_VSD_ISID_v1.csv', 'T5_VSD_ISID_v1.csv'],
}

def extract_values(file_path):
    try:

        df = pd.read_csv(file_path, header=None)


        vgs_values = df.iloc[4, 1:9].tolist()
        print(f'VGS values from {file_path} (row 5, columns B to I): {vgs_values}')


        df = pd.read_csv(file_path, skiprows=4)


        vd_values = df.iloc[:, 0].tolist()
        print(f'Vd values from {file_path}: {vd_values}')


        is_values = df.iloc[:, 1:9]
        id_values = df.iloc[:, 9:17]


        isd_values = id_values.subtract(is_values.values)

        for idx, vgs in enumerate(vgs_values):
            is_vals = is_values.iloc[:, idx].tolist()
            id_vals = id_values.iloc[:, idx].tolist()
            isd_vals = isd_values.iloc[:, idx].tolist()
            print(f'For Vgs = {vgs} from {file_path}:')
            print(f'  Is values: {is_vals}')
            print(f'  Id values: {id_vals}')
            print(f'  Isd values: {isd_vals}')

        return vd_values, vgs_values, is_values, id_values, isd_values
    except Exception as e:
        print(f"Error reading {file_path}: {e}")
        return None, None, None, None, None


def compute_average_isd(tool, files):
    combined_isd = None
    vgs_values = None
    vd_values = None

    for file_name in files:
        file_path = os.path.join(folder_path, tool, file_name)
        if os.path.exists(file_path):
            vd_vals, vgs_vals, _, _, isd_values = extract_values(file_path)
            if isd_values is not None:
                if combined_isd is None:
                    combined_isd = isd_values
                    vgs_values = vgs_vals
                    vd_values = vd_vals
                else:
                    combined_isd = combined_isd.add(isd_values, fill_value=0)
        else:
            print(f"File not found: {file_path}")

    if combined_isd is not None and len(files) > 0:

        average_isd = combined_isd / len(files)
        return vd_values, vgs_values, average_isd
    else:
        return None, None, None


average_isd_values = {}

for tool, files in chip_files.items():
    vd_values, vgs_values, average_isd = compute_average_isd(tool, files)
    if vgs_values is not None and average_isd is not None:
        average_isd_values[tool] = (vd_values, vgs_values, average_isd)


for tool, (vd_values, vgs_values, avg_isd) in average_isd_values.items():
    print(f"\nSummary for {tool}:")
    print(f"  Vd values: {vd_values}")
    print(f"  Vgs values: {vgs_values}")
    for idx, vgs in enumerate(vgs_values):
        avg_isd_vals = avg_isd.iloc[:, idx].tolist()
        print(f'  Average Isd values for Vgs = {vgs}: {avg_isd_vals}')


target_vgs = '-2.800000 (none)'
for tool, (vd_values, vgs_values, avg_isd) in average_isd_values.items():
    if target_vgs in vgs_values:
        idx = vgs_values.index(target_vgs)
        avg_isd_vals = avg_isd.iloc[:, idx].tolist()
        print(f"\nFocused Summary for {tool}:")
        print(f"  Vd values: {vd_values}")
        print(f"  Vgs values: {vgs_values}")
        print(f"  Average Isd values for Vgs = {target_vgs}: {avg_isd_vals}")


def get_average_isd_df(average_isd_values):
    avg_isd_df = pd.DataFrame()
    for tool, (vd_values, vgs_values, avg_isd) in average_isd_values.items():
        avg_isd_df[tool] = avg_isd.mean(axis=1)
    return avg_isd_df


average_isd_df = get_average_isd_df(average_isd_values)

"""#Part 1"""

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

file_path = '/content/drive/My Drive/Test-Data-OEGFET.csv'

data = pd.read_csv(file_path, usecols=['X-Axis (V)', 'MWT1', 'MWT2', 'MWT3', 'MWT4', 'MWT5'])

data.set_index('X-Axis (V)', inplace=True)

transformed_data = data.applymap(lambda x: np.abs(np.sqrt(x)))

plt.figure(figsize=(10, 6))
for column in transformed_data.columns:
    plt.plot(transformed_data.index, transformed_data[column], label=column)

plt.title('Transformed Current vs Voltage Characteristics')
plt.xlabel('Voltage (V)')
plt.ylabel('Transformed Current (sqrt(A))')
plt.legend()
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

file_path = '/content/drive/My Drive/Test-Data-OEGFET.csv'

data = pd.read_csv(file_path, usecols=['X-Axis (V)', 'MWT1', 'MWT2', 'MWT3', 'MWT4', 'MWT5'])

data.set_index('X-Axis (V)', inplace=True)

transformed_data = data.applymap(lambda x: np.abs(np.sqrt(x)))

def find_flat_region(x, y, threshold_factor=0.1):
    dy = np.gradient(y, x)
    threshold = np.mean(np.abs(dy)) * threshold_factor
    flat_indices = np.where(np.abs(dy) < threshold)[0]
    if flat_indices.size > 0:
        return flat_indices[0], flat_indices[-1]
    return None, None

def find_sloped_region(x, y, flat_start, threshold_factor=0.5):
    if flat_start is None or flat_start == 0:
        return None
    dy = np.gradient(y[:flat_start], x[:flat_start])
    threshold = np.mean(np.abs(dy)) * threshold_factor
    sloped_indices = np.where(np.abs(dy) > threshold)[0]
    if sloped_indices.size > 0:
        return sloped_indices[0], sloped_indices[-1]
    return None, None

def plot_slope(x, y, x_full, color, label):
    slope, intercept = np.polyfit(x, y, 1)
    y_fit = slope * x_full + intercept
    plt.plot(x_full, y_fit, color + '--', label=label + f' slope: {slope:.2e}, R^2: {calc_r_squared(x, y, slope, intercept):.2f}')
    return slope, intercept

def calc_r_squared(x, y, slope, intercept):
    y_fit = slope * x + intercept
    ss_res = np.sum((y - y_fit) ** 2)
    ss_tot = np.sum((y - np.mean(y)) ** 2)
    r_squared = 1 - (ss_res / ss_tot)
    return r_squared

def analyze_column(data, column_name, x_full):
    x = data.index.to_numpy()
    y = data[column_name].to_numpy()

    plt.plot(x, y, label=f'{column_name} Data', alpha=0.3)

    flat_start, flat_end = find_flat_region(x, y, threshold_factor=0.2)
    if flat_start is not None and flat_end is not None:
        slope_flat, intercept_flat = plot_slope(x[flat_start:flat_end+1], y[flat_start:flat_end+1], x_full, 'g', f'{column_name} Flat Region')
    else:
        slope_flat, intercept_flat = None, None

    if flat_start is None and flat_end is None:
        print(f"{column_name} does not have a flat region, identifying two sloped regions instead.")
        slope_start, slope_end = 0, len(y) - 1
        slope1, intercept1 = plot_slope(x[slope_start:(slope_end//2)+1], y[slope_start:(slope_end//2)+1], x_full, 'b', f'{column_name} Sloped Region 1')
        slope2, intercept2 = plot_slope(x[(slope_end//2)+1:slope_end+1], y[(slope_end//2)+1:slope_end+1], x_full, 'm', f'{column_name} Sloped Region 2')

        if np.isclose(slope1, slope2, atol=1e-2):
            print(f"Error: The slopes for {column_name} are too similar, indicating no distinct regions.")
        else:
            x_intersect = (intercept2 - intercept1) / (slope1 - slope2)
            y_intersect = slope1 * x_intersect + intercept1
            plt.plot(x_intersect, y_intersect, 'ko', markersize=10, label=f'Intersection {column_name} ({x_intersect:.2f}, {y_intersect:.2e})')
            print(f'Intersection for {column_name}: x = {x_intersect:.2f}, y = {y_intersect:.2e}')
    else:
        if flat_start is not None:
            slope_start, slope_end = find_sloped_region(x, y, flat_start, threshold_factor=1.0)
            if slope_start is not None and slope_end is not None:
                slope_increasing, intercept_increasing = plot_slope(x[slope_start:slope_end+1], y[slope_start:slope_end+1], x_full, 'r', f'{column_name} Sloped Region')

                if slope_flat != slope_increasing:
                    x_intersect = (intercept_increasing - intercept_flat) / (slope_flat - slope_increasing)
                    y_intersect = slope_increasing * x_intersect + intercept_increasing
                    plt.plot(x_intersect, y_intersect, 'ko', markersize=10, label=f'Intersection {column_name} ({x_intersect:.2f}, {y_intersect:.2e})')
                    print(f'Intersection for {column_name}: x = {x_intersect:.2f}, y = {y_intersect:.2e}')

plt.figure(figsize=(15, 10))
x_full = np.linspace(transformed_data.index.min(), transformed_data.index.max(), 500)
for column in transformed_data.columns:
    analyze_column(transformed_data, column, x_full)


plt.title('Transformed Current vs Voltage Characteristics for MWT1, MWT2, MWT3, MWT4, and MWT5')
plt.xlabel('Voltage (V)')
plt.ylabel('Transformed Current (sqrt(A))')
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)
plt.grid(True)
plt.show()

"""#Part 2"""

import matplotlib.pyplot as plt
import pandas as pd

x_values = [2.45, 2.1, 1.75, 1.4, 1.05, 0.7, 0.35, 0]

y_values = {
    0.0: [0.001356911, 0.001576656, -0.000229268, 0.000129555, -0.00032215, -0.000166431, -0.002003551, -0.006905754],
    0.1: [0.007658504, 0.00709309, 0.004476904, 0.00235071, 0.000742812, 9.851e-05, -0.001530227, -0.006305452],
    0.2: [0.015915393, 0.01352915, 0.00932644, 0.004399675, 0.001610762, 0.000636714, -0.000948747, -0.005732702],
    0.3: [0.02628307, 0.019841455, 0.013757802, 0.006230394, 0.001964849, 0.000477217, -0.000370215, -0.00545782],
    0.4: [0.040083023, 0.02700744, 0.017532346, 0.00782745, 0.002098967, 0.00063198, 1.4e-05, -0.005261847],
    0.5: [0.055544064, 0.034273362, 0.021047187, 0.009147227, 0.00284624, 0.000306883, 0.000348737, -0.005668852],
    0.6: [0.07219192, 0.04195199, 0.024651181, 0.01047497, 0.003024027, 0.000899632, 0.000617064, -0.005032556],
    0.7: [0.08920753, 0.049857944, 0.027529346, 0.011744694, 0.003807245, 0.001141566, 0.00100834, -0.004835822],
    0.8: [0.105775668, 0.057856401, 0.030551447, 0.013231857, 0.004459096, 0.00241475, 0.001330738, -0.003876331],
    0.9: [0.121564277, 0.065595927, 0.033398451, 0.014788312, 0.005343514, 0.0033617, 0.001483482, -0.003513578],
    1.0: [0.129845911, 0.072459003, 0.036751669, 0.016382992, 0.005881662, 0.00375511, 0.00171154, -0.00206237]
}

plt.figure(figsize=(10, 6))
for key, values in y_values.items():
    plt.plot(x_values, values, label=f'{key}')

plt.xlabel('VSG (V)')
plt.ylabel('Isd (A)')
plt.legend(title='Vd values', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.title('Isd vs VSG for different Vd values')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

x_values = np.array([0, 0.35, 0.7, 1.05, 1.4, 1.75, 2.1, 2.45])

y_values = {
    0.0: [-0.006905754, -0.002003551, -0.000166431, -0.00032215, 0.000129555, -0.000229268, 0.001576656, 0.001356911],
    0.1: [-0.006305452, -0.001530227, 9.851e-05, 0.000742812, 0.00235071, 0.004476904, 0.00709309, 0.007658504],
    0.2: [-0.005732702, -0.000948747, 0.000636714, 0.001610762, 0.004399675, 0.00932644, 0.01352915, 0.015915393],
    0.3: [-0.00545782, -0.000370215, 0.000477217, 0.001964849, 0.006230394, 0.013757802, 0.019841455, 0.02628307],
    0.4: [-0.005261847, 1.4e-05, 0.00063198, 0.002098967, 0.00782745, 0.017532346, 0.02700744, 0.040083023],
    0.5: [-0.005668852, 0.000348737, 0.000306883, 0.00284624, 0.009147227, 0.021047187, 0.034273362, 0.055544064],
    0.6: [-0.005032556, 0.000617064, 0.000899632, 0.003024027, 0.01047497, 0.024651181, 0.04195199, 0.07219192],
    0.7: [-0.004835822, 0.00100834, 0.001141566, 0.003807245, 0.011744694, 0.027529346, 0.049857944, 0.08920753],
    0.8: [-0.003876331, 0.001330738, 0.00241475, 0.004459096, 0.013231857, 0.030551447, 0.057856401, 0.105775668],
    0.9: [-0.003513578, 0.001483482, 0.0033617, 0.005343514, 0.014788312, 0.033398451, 0.065595927, 0.121564277],
    1.0: [-0.00206237, 0.00171154, 0.00375511, 0.005881662, 0.016382992, 0.036751669, 0.072459003, 0.129845911]
}

threshold_vgs = 2.0

plt.figure(figsize=(10, 6))
gm_values = {}
curve_labels = {}

all_max_slopes = []
for values in y_values.values():
    slopes = np.diff(values) / np.diff(x_values)
    all_max_slopes.append(np.max(np.abs(slopes)))

threshold_for_off = np.percentile(all_max_slopes, 50)

for key, values in y_values.items():
    x = np.array(x_values).reshape(-1, 1)
    y = np.array(values).reshape(-1, 1)

    slopes = np.diff(y.flatten()) / np.diff(x.flatten())
    max_slope = np.max(np.abs(slopes))

    if max_slope < threshold_for_off:
        curve_labels[key] = "Off"
        plt.plot(x, y, label=f'{key} (Off)', linestyle='-.')
    else:
        curve_labels[key] = "On"
        slopes_right_to_left = np.diff(y.flatten()[::-1]) / np.diff(x.flatten()[::-1])
        on_region_start_index = len(slopes_right_to_left) - np.argmax(slopes_right_to_left > np.percentile(slopes_right_to_left, 75)) - 1

        if on_region_start_index < len(x):
            x_on_region = x[on_region_start_index:]
            y_on_region = y[on_region_start_index:]

            reg = LinearRegression().fit(x_on_region, y_on_region)
            gm = reg.coef_[0][0]
            gm_values[key] = gm

            plt.plot(x, y, label=f'{key} (On)')
            plt.plot(x_on_region, reg.predict(x_on_region), linestyle='--')

            extended_x = np.linspace(x[on_region_start_index, 0], x[-1, 0], 100).reshape(-1, 1)
            plt.plot(extended_x, reg.predict(extended_x), linestyle=':', label=f'Slope {key} (gm={gm:.4f}, R^2={reg.score(x_on_region, y_on_region):.2f})')
        else:
            gm_values[key] = np.nan

plt.xlabel('VGS (V)')
plt.ylabel('Isd (A)')
plt.legend(title='Vd values', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.title('Isd vs VGS with gm slopes (On/Off Region)')
plt.grid(True)
plt.show()

for key, gm in gm_values.items():
    label = curve_labels[key]
    if label == "On":
        print(f'gm for Vd = {key} (On): {gm:.4f}')
    else:
        print(f'Curve for Vd = {key} is Off, showing linear or inactive behavior.')

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from scipy.interpolate import make_interp_spline

x_values = np.array([0, 0.35, 0.7, 1.05, 1.4, 1.75, 2.1, 2.45])

y_values = {
    0.0: [-0.006905754, -0.002003551, -0.000166431, -0.00032215, 0.000129555, -0.000229268, 0.001576656, 0.001356911],
    0.1: [-0.006305452, -0.001530227, 9.851e-05, 0.000742812, 0.00235071, 0.004476904, 0.00709309, 0.007658504],
    0.2: [-0.005732702, -0.000948747, 0.000636714, 0.001610762, 0.004399675, 0.00932644, 0.01352915, 0.015915393],
    0.3: [-0.00545782, -0.000370215, 0.000477217, 0.001964849, 0.006230394, 0.013757802, 0.019841455, 0.02628307],
    0.4: [-0.005261847, 1.4e-05, 0.00063198, 0.002098967, 0.00782745, 0.017532346, 0.02700744, 0.040083023],
    0.5: [-0.005668852, 0.000348737, 0.000306883, 0.00284624, 0.009147227, 0.021047187, 0.034273362, 0.055544064],
    0.6: [-0.005032556, 0.000617064, 0.000899632, 0.003024027, 0.01047497, 0.024651181, 0.04195199, 0.07219192],
    0.7: [-0.004835822, 0.00100834, 0.001141566, 0.003807245, 0.011744694, 0.027529346, 0.049857944, 0.08920753],
    0.8: [-0.003876331, 0.001330738, 0.00241475, 0.004459096, 0.013231857, 0.030551447, 0.057856401, 0.105775668],
    0.9: [-0.003513578, 0.001483482, 0.0033617, 0.005343514, 0.014788312, 0.033398451, 0.065595927, 0.121564277],
    1.0: [-0.00206237, 0.00171154, 0.00375511, 0.005881662, 0.016382992, 0.036751669, 0.072459003, 0.129845911]
}

threshold_vgs = 2.0

plt.figure(figsize=(10, 6))
gm_values = {}
curve_labels = {}

all_max_slopes = []
for values in y_values.values():
    slopes = np.diff(values) / np.diff(x_values)
    all_max_slopes.append(np.max(np.abs(slopes)))

threshold_for_off = np.percentile(all_max_slopes, 50)

for key, values in y_values.items():
    x = np.array(x_values).reshape(-1, 1)
    y = np.array(values).reshape(-1, 1)

    slopes = np.diff(y.flatten()) / np.diff(x.flatten())
    max_slope = np.max(np.abs(slopes))

    if max_slope < threshold_for_off:
        curve_labels[key] = "Off"
        spline = make_interp_spline(x.flatten(), y.flatten(), k=3)
        x_smooth = np.linspace(x.min(), x.max(), 300)
        y_smooth = spline(x_smooth)
        plt.plot(x_smooth, y_smooth, label=f'{key} (Off)', linestyle='-.')
    else:
        curve_labels[key] = "On"
        slopes_right_to_left = np.diff(y.flatten()[::-1]) / np.diff(x.flatten()[::-1])
        on_region_start_index = len(slopes_right_to_left) - np.argmax(slopes_right_to_left > np.percentile(slopes_right_to_left, 75)) - 1

        if on_region_start_index < len(x):
            x_on_region = x[on_region_start_index:]
            y_on_region = y[on_region_start_index:]

            reg = LinearRegression().fit(x_on_region, y_on_region)
            gm = reg.coef_[0][0]
            gm_values[key] = gm

            spline = make_interp_spline(x.flatten(), y.flatten(), k=3)
            x_smooth = np.linspace(x.min(), x.max(), 300)
            y_smooth = spline(x_smooth)
            plt.plot(x_smooth, y_smooth, label=f'{key} (On)')
            plt.plot(x_on_region, reg.predict(x_on_region), linestyle='--')

            extended_x = np.linspace(x[on_region_start_index, 0], x[-1, 0], 100).reshape(-1, 1)
            plt.plot(extended_x, reg.predict(extended_x), linestyle=':', label=f'Slope {key} (gm={gm:.4f}, R^2={reg.score(x_on_region, y_on_region):.2f})')
        else:
            gm_values[key] = np.nan

plt.xlabel('VGS (V)')
plt.ylabel('Isd (A)')
plt.legend(title='Vd values', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.title('Isd vs VGS with gm slopes (On/Off Region)')
plt.grid(True)
plt.show()

for key, gm in gm_values.items():
    label = curve_labels[key]
    if label == "On":
        print(f'gm for Vd = {key} (On): {gm:.4f}')
    else:
        print(f'Curve for Vd = {key} is Off, showing linear or inactive behavior.')

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from scipy.interpolate import make_interp_spline

x_values = np.array([0, 0.35, 0.7, 1.05, 1.4, 1.75, 2.1, 2.45])

y_values = {
    0.0: [-0.006905754, -0.002003551, -0.000166431, -0.00032215, 0.000129555, -0.000229268, 0.001576656, 0.001356911],
    0.1: [-0.006305452, -0.001530227, 9.851e-05, 0.000742812, 0.00235071, 0.004476904, 0.00709309, 0.007658504],
    0.2: [-0.005732702, -0.000948747, 0.000636714, 0.001610762, 0.004399675, 0.00932644, 0.01352915, 0.015915393],
    0.3: [-0.00545782, -0.000370215, 0.000477217, 0.001964849, 0.006230394, 0.013757802, 0.019841455, 0.02628307],
    0.4: [-0.005261847, 1.4e-05, 0.00063198, 0.002098967, 0.00782745, 0.017532346, 0.02700744, 0.040083023],
    0.5: [-0.005668852, 0.000348737, 0.000306883, 0.00284624, 0.009147227, 0.021047187, 0.034273362, 0.055544064],
    0.6: [-0.005032556, 0.000617064, 0.000899632, 0.003024027, 0.01047497, 0.024651181, 0.04195199, 0.07219192],
    0.7: [-0.004835822, 0.00100834, 0.001141566, 0.003807245, 0.011744694, 0.027529346, 0.049857944, 0.08920753],
    0.8: [-0.003876331, 0.001330738, 0.00241475, 0.004459096, 0.013231857, 0.030551447, 0.057856401, 0.105775668],
    0.9: [-0.003513578, 0.001483482, 0.0033617, 0.005343514, 0.014788312, 0.033398451, 0.065595927, 0.121564277],
    1.0: [-0.00206237, 0.00171154, 0.00375511, 0.005881662, 0.016382992, 0.036751669, 0.072459003, 0.129845911]
}

threshold_vgs = 2.0

plt.figure(figsize=(10, 6))
gm_values = {}
curve_labels = {}

all_max_slopes = []
for key, values in y_values.items():
    spline = make_interp_spline(x_values, values, k=3)
    x_smooth = np.linspace(x_values.min(), x_values.max(), 300)
    y_smooth = spline(x_smooth)

    slopes = np.diff(y_smooth) / np.diff(x_smooth)
    all_max_slopes.append(np.max(np.abs(slopes)))

threshold_for_off = np.percentile(all_max_slopes, 50)

for key, values in y_values.items():
    spline = make_interp_spline(x_values, values, k=3)
    x_smooth = np.linspace(x_values.min(), x_values.max(), 300)
    y_smooth = spline(x_smooth)

    slopes = np.diff(y_smooth) / np.diff(x_smooth)
    max_slope = np.max(np.abs(slopes))

    if max_slope < threshold_for_off:
        curve_labels[key] = "Off"
        plt.plot(x_smooth, y_smooth, label=f'{key} (Off)', linestyle='-.')
    else:
        curve_labels[key] = "On"
        slopes_right_to_left = np.diff(y_smooth[::-1]) / np.diff(x_smooth[::-1])
        on_region_start_index = len(slopes_right_to_left) - np.argmax(slopes_right_to_left > np.percentile(slopes_right_to_left, 75)) - 1

        if on_region_start_index < len(x_smooth):
            x_on_region = x_smooth[on_region_start_index:].reshape(-1, 1)
            y_on_region = y_smooth[on_region_start_index:].reshape(-1, 1)

            reg = LinearRegression().fit(x_on_region, y_on_region)
            gm = reg.coef_[0][0]
            gm_values[key] = gm

            plt.plot(x_smooth, y_smooth, label=f'{key} (On)')
            plt.plot(x_on_region, reg.predict(x_on_region), linestyle='--')

            extension_factor = 0.1
            extended_x = np.linspace(x_smooth[on_region_start_index] - extension_factor, x_smooth[-1] + extension_factor, 100).reshape(-1, 1)
            # extended_x = np.linspace(x_smooth[on_region_start_index], x_smooth[-1], 100).reshape(-1, 1)
            plt.plot(extended_x, reg.predict(extended_x), linestyle=':', linewidth=2, label=f'Slope {key} (gm={gm:.4f}, R^2={reg.score(x_on_region, y_on_region):.2f})')
        else:
            gm_values[key] = np.nan

plt.xlabel('VGS (V)')
plt.ylabel('Isd (A)')
plt.legend(title='Vd values', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.title('Isd vs VGS with gm slopes (On/Off Region)')
plt.grid(True)
plt.show()

for key, gm in gm_values.items():
    label = curve_labels[key]
    if label == "On":
        print(f'gm for Vd = {key} (On): {gm:.4f}')
    else:
        print(f'Curve for Vd = {key} is Off, showing linear or inactive behavior.')

